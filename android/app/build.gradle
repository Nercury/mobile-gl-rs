import org.gradle.nativeplatform.tasks.LinkSharedLibrary

apply plugin: 'com.android.model.application'

def versionCodeBase = 11;
def appPlatforms = [
    'armeabi': [
        enabled: true,
        flavorName: 'arm',
        versionCodePrefix: 1,
        rustTarget: 'arm-linux-androideabi',
    ],
    'armeabi-v7a': [
        enabled: true,
        flavorName: 'arm7',
        versionCodePrefix: 2,
        rustTarget: 'arm-linux-androideabi',
    ],
    'arm64-v8a': [
        enabled: true,
        flavorName: 'arm64',
        versionCodePrefix: 3,
        rustTarget: 'aarch64-linux-android',
    ],
    'mips': [
        enabled: false,
        flavorName: 'mips',
        versionCodePrefix: 5,
        rustTarget: 'unavailable-rust-arch-mips',
    ],
    'mips64': [
        enabled: false,
        flavorName: 'mips64',
        versionCodePrefix: 6,
        rustTarget: 'unavailable-rust-arch-mips64',
    ],
    'x86': [
        enabled: true,
        flavorName: 'x86',
        versionCodePrefix: 8,
        rustTarget: 'i686-linux-android',
    ],
    'x86_64': [
        enabled: false,
        flavorName: 'x86_64',
        versionCodePrefix: 9,
        rustTarget: 'unavailable-rust-arch-x86_64',
    ]
];

def cargoBinary = '/usr/local/bin/cargo'
def multirustBinary = '/usr/local/bin/multirust'

def crateName = "inl"
def depsDir = rootDir.getParent()
def crateDir = new File(depsDir, crateName)
def crateTargetDir = new File(crateDir, "target")
def crateIncludeDir = new File(crateTargetDir, "include")
def crateIncludeFile = new File(crateIncludeDir, "inl.h")

model {
    android {
        compileSdkVersion = 23
        buildToolsVersion = "23.0.2"

        defaultConfig.with {
            applicationId = "com.trafi.inspector"
            minSdkVersion.apiLevel = 17
            targetSdkVersion.apiLevel = 23
            versionCode = versionCodeBase
            versionName = versionCodeBase + ".0"
        }
    }
    android.ndk {
        moduleName = "glass-activity"
        stl = "stlport_static" // gnustl or stlport

        cppFlags.add("-std=c++14") // Add provisions to allow C++11 functionality
        cppFlags.add("-fexceptions")
        cppFlags.add("-I${crateIncludeDir}".toString())
        cppFlags.add("-I${file("src/main/jni/glass-activity")}".toString())

        ldLibs.addAll(
            [
                "log", "android", "EGL", "GLESv1_CM"
            ]
        )
    }
    android.buildTypes {
        release {
            minifyEnabled = false
        }
        debug {
            debuggable = true
            minifyEnabled = false
        }
    }
    android.productFlavors {
        appPlatforms.each { p ->
            if (p.value.enabled) {
                create(p.value.flavorName) {
                    ndk.abiFilters.add(p.key)
                    versionCode = p.value.versionCodePrefix * 1000000 + versionCodeBase
                }
            }
        }
        create("fat") {
            versionCode = versionCodeBase
            appPlatforms.each { p ->
                if (p.value.enabled) {
                    ndk.abiFilters.add(p.key)
                }
            }
        }
    }
}

// Run cargo build for library to generate target/include/ headers
task buildIncludeHeaders {
    inputs.dir new File(crateDir, 'src')
    inputs.file new File(crateDir, 'build.rs')
    inputs.file new File(crateDir, 'Cargo.toml')
    outputs.file crateIncludeFile

    doFirst {
        println "building rust include headers"
        exec {
            workingDir crateDir
            executable cargoBinary
            args = ["build", "-j", "8"]
        }
    }
}

tasks.whenTaskAdded { t ->
    if (t.path.contains(":compile")) {
        t.inputs.file crateIncludeFile
        t.dependsOn buildIncludeHeaders
    }
}

// For every existing platform, create a task to build rust library with correct target
tasks.whenTaskAdded { t ->
    if (!(t instanceof LinkSharedLibrary)) {
        return;
    }

    def platform = t.properties.get("targetPlatform")
    def buildType = t.name.contains("Release") ? "release" : "debug"

    def rustTarget = appPlatforms.get(platform.name).rustTarget

    def targetPlatformDir = new File(crateTargetDir, rustTarget)
    def targetBuildTypeDir = new File(targetPlatformDir, buildType)
    def targetLibFile = new File(targetBuildTypeDir, "lib" + crateName + ".a")

    def linkerArgs = t.properties.get('linkerArgs');
    linkerArgs.add("-l" + targetLibFile.getPath() + "")
    t.properties['linkerArgs'] = linkerArgs
    t.inputs.file crateIncludeFile
    t.inputs.file targetLibFile

    t.dependsOn task("rust-$t.name", { rustTask ->
        inputs.property "buildType", buildType
        inputs.dir new File(crateDir, 'src')
        inputs.dir new File(crateDir, '../../egli/src')
        inputs.file new File(crateDir, 'build.rs')
        inputs.file new File(crateDir, 'Cargo.toml')
        outputs.file targetLibFile

        doFirst {
            println "building rust lib " + crateName + " on " + platform + " with " + rustTarget + " target"

            exec {
                workingDir crateDir
                executable multirustBinary
                args = ["override", "android"]
            }

            def buildArgs = ["build", "--target=" + rustTarget, "-j", "8"]
            if (buildType == "release") {
                buildArgs.add("--release")
            }

            exec {
                workingDir crateDir
                executable cargoBinary
                args = buildArgs
            }
        }
    })
}
apply plugin: 'com.android.model.application'

def versionCodeBase = 11;
def appPlatforms = [
        'armeabi'    : [
                enabled          : true,
                flavorName       : 'arm',
                versionCodePrefix: 1,
                rustTarget       : 'arm-linux-androideabi',
        ],
        'armeabi-v7a': [
                enabled          : true,
                flavorName       : 'arm7',
                versionCodePrefix: 2,
                rustTarget       : 'armv7-linux-androideabi',
        ],
        'arm64-v8a'  : [
                enabled          : true,
                flavorName       : 'arm64',
                versionCodePrefix: 3,
                rustTarget       : 'aarch64-linux-android',
        ],
        'mips'       : [
                enabled          : false,
                flavorName       : 'mips',
                versionCodePrefix: 5,
                rustTarget       : 'unavailable-rust-arch-mips',
        ],
        'mips64'     : [
                enabled          : false,
                flavorName       : 'mips64',
                versionCodePrefix: 6,
                rustTarget       : 'unavailable-rust-arch-mips64',
        ],
        'x86'        : [
                enabled          : false,
                flavorName       : 'x86',
                versionCodePrefix: 8,
                rustTarget       : 'i686-linux-android',
        ],
        'x86_64'     : [
                enabled          : false,
                flavorName       : 'x86_64',
                versionCodePrefix: 9,
                rustTarget       : 'unavailable-rust-arch-x86_64',
        ]
];

def cargoBinary = '/usr/local/bin/cargo'
def multirustBinary = '/usr/local/bin/multirust'

def crateName = "inl"
def depsDir = rootDir.getParent()
def crateDir = new File(depsDir, crateName)
def crateTargetDir = new File(crateDir, "target")
def crateIncludeDir = new File(crateTargetDir, "include")

model {
    android {
        compileSdkVersion = 23
        buildToolsVersion = "23.0.2"

        defaultConfig.with {
            applicationId = "com.trafi.inspector"
            minSdkVersion.apiLevel = 17
            targetSdkVersion.apiLevel = 23
            versionCode = versionCodeBase
            versionName = versionCodeBase + ".0"
        }
    }
    android.ndk {
//        toolchain "clang"
        moduleName = "glass-activity"
        stl = "stlport_static" // gnustl or stlport

        cppFlags.add("-std=c++14") // Add provisions to allow C++11 functionality
        cppFlags.add("-fexceptions")
        cppFlags.add("-I${crateIncludeDir}".toString())
        cppFlags.add("-I${file("src/main/jni/glass-activity")}".toString())

        ldLibs.addAll(
                [
                        "log", "android", "EGL", "GLESv1_CM"
                ]
        )
    }
    android.buildTypes {
        release {
            minifyEnabled = false
        }
        debug {
            debuggable = true
            minifyEnabled = false
        }
    }
    android.productFlavors {
        appPlatforms.each { p ->
            if (p.value.enabled) {
                create(p.value.flavorName) {
                    ndk.abiFilters.add(p.key)
                    versionCode = p.value.versionCodePrefix * 1000000 + versionCodeBase
                }
            }
        }
        create("fat") {
            versionCode = versionCodeBase
            appPlatforms.each { p ->
                if (p.value.enabled) {
                    ndk.abiFilters.add(p.key)
                }
            }
        }
    }
}

for (appPlatform in appPlatforms.entrySet()) {
    for (buildType in ["debug", "release"]) {
        def platform = appPlatform.key;
        def rustTarget = appPlatform.value.rustTarget

        def targetPlatformDir = new File(crateTargetDir, rustTarget)
        def targetBuildTypeDir = new File(targetPlatformDir, buildType)
        def targetLibFile = new File(targetBuildTypeDir, "lib" + crateName + ".a")

        def t = tasks.create("rust-$platform-$buildType", { rustTask ->
            inputs.dir new File(crateDir, 'src')
            inputs.dir new File(crateDir, '../../egli-rs/src')
            inputs.dir new File(crateDir, '../../kugel-rs/src')
            inputs.dir new File(crateDir, '../../android_looper/src')
            inputs.dir new File(crateDir, '../../android_looper-sys/src')
            inputs.dir new File(crateDir, '../../android_sensor/src')
            inputs.dir new File(crateDir, '../../android_sensor-sys/src')
            inputs.file new File(crateDir, 'build.rs')
            inputs.file new File(crateDir, 'Cargo.toml')
            outputs.file targetLibFile
            inputs.property "buildType", buildType

            doLast {
                println "building rust lib " + crateName + " for " + rustTarget + " target"

                exec {
                    workingDir crateDir
                    executable multirustBinary
                    args = ["override", "nightly"]
                }

                def buildArgs = ["build", "--target=" + rustTarget, "-j", "8"]
                if (buildType == "release") {
                    buildArgs.add("--release")
                }

                exec {
                    workingDir crateDir
                    executable cargoBinary
                    args = buildArgs
                }
            }
        })
    }
}

// For every existing platform, create a task to build rust library with correct target
tasks.whenTaskAdded { t ->
    if (!(t instanceof org.gradle.nativeplatform.tasks.LinkSharedLibrary)) {
        return;
    }

    def platform = t.properties.get("targetPlatform").name
    def buildType = t.name.contains("Release") ? "release" : "debug"

    def rustTarget = appPlatforms.get(platform).rustTarget

    def targetPlatformDir = new File(crateTargetDir, rustTarget)
    def targetBuildTypeDir = new File(targetPlatformDir, buildType)
    def targetLibFile = new File(targetBuildTypeDir, "lib" + crateName + ".a")

    def linkerArgs = t.properties.get('linkerArgs');
    linkerArgs.add("-L" + targetBuildTypeDir.getPath() + "")
    linkerArgs.add("-l" + crateName + "")
    t.properties['linkerArgs'] = linkerArgs
    t.inputs.file targetLibFile
}

// For every existing platform, create a task to build rust library with correct target
tasks.whenTaskAdded { t ->
    if (!(t instanceof org.gradle.nativeplatform.tasks.CreateStaticLibrary)) {
        return;
    }

    def platform = t.properties.get("targetPlatform").name
    def buildType = t.name.contains("Release") ? "release" : "debug"

    println("platform: $platform")
    println("buildType: $buildType")

    def rustTask = tasks.findByName("rust-$platform-$buildType")
    if (rustTask != null) {
        println "found " + rustTask.name
        t.dependsOn rustTask
    }

}
